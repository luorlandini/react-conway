{"version":3,"sources":["hooks/useInterval.js","hooks/useWindowSize.js","util.js","hooks/useBoard.js","parser/rle.js","components/Brushes.js","components/Controls.js","App.js","serviceWorker.js","index.js"],"names":["useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","useWindowSize","isClient","window","getSize","useCallback","width","innerWidth","undefined","height","innerHeight","useState","windowSize","setWindowSize","handleResize","addEventListener","removeEventListener","indexToCoord","index","cols","x","y","Math","floor","coordToIndex","calcNeighborCoordinate","yd","yTotal","m","handleBoardDimensionChange","board","cCols","cRows","nCols","nRows","colDiff","rowDiff","nBoard","colsToAdd","i","newColsAdded","currentPosition","splice","Array","fill","addCols","colsToRemove","abs","removeCols","rowsToAdd","addRows","slice","removeRows","getBoardWithAppliedBrushAndPaintedIndices","bCols","bRows","brush","brushDistanceVec","distanceVec","paintedIndices","Set","l","length","template","xd","boardIndex","add","countNeighbors","COLS","ROWS","neighborCount","xCoord2D","yCoord2D","useBoard","rows","seed","setBoard","isRunning","setIsRunning","newBoard","boardLength","coord","every","cell","isDesolate","addBrushName","patternString","brushName","searchIndex","commentRegex","comments","exec","lastIndex","push","split","name","displayName","e","console","log","addRowsAndCols","configRegex","config","parseInt","addTemplateToBrush","chr","totalSize","Uint8Array","positionInTemplate","count","in_number","currentX","len","charCodeAt","url","a","fetch","response","decoder","TextDecoder","reader","body","getReader","rleFileString","read","done","value","decode","brushDistanceVecFromCenter","centerCoord","bcx","bcy","distanceVecsFromCenter","brushSize","cbpx","cbpy","rotateBrush90deg","newTemplate","rotatedTemplate","rotateTemplate90deg","defaultBrush","brushList","useBrushes","brushes","setBrushes","loaded","setLoaded","filteredBrushes","setFilteredBrushes","Promise","all","map","parseRle","process","then","vals","smallerThanBoard","filter","BrushSelector","onChange","selectedBrush","brushesLoaded","className","key","Controls","advanceBoard","toggleIsRunning","setSelectedBrushWrapper","touchHoverClear","setLastPaintedIndices","memoBoardReset","event","code","type","document","memoNext","onTouchStart","onClick","b","getBrush","target","blur","lastHoverCoord","mousePosToCoord","eX","eY","intersection","setA","setB","_intersection","elem","has","CanvasBoard","setCols","setRows","setHoverBoard","hoverBoard","lastPaintedHoverIndices","lastPaintedIndices","setLastPaintedHoverIndices","canvasRef","drawCell","ctx","fillStyle","fillRect","drawHoverCell","newRows","newCols","getContext","clearRect","clearCanvas","ref","size","cCoord","pageX","pageY","onMouseLeave","onTouchEnd","changedTouches","clientX","clientY","preventDefault","onTouchMove","touches","onMouseMove","buttons","BoardWrapper","setSelectedBrush","setSelectedBrushCb","newBrush","keyCode","memoRotateBrush","App","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.190334bc.chunk.js","sourcesContent":["import {useEffect, useRef} from \"react\";\n\n\nfunction useInterval(callback, delay) {\n    const savedCallback = useRef();\n\n    // Remember the latest callback.\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval.\n    useEffect(() => {\n        function tick() {\n            savedCallback.current();\n        }\n\n        if (delay !== null) {\n            let id = setInterval(tick, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}\n\nexport default useInterval;\n","import {useState, useEffect, useCallback} from 'react';\n\n// Hook\nfunction useWindowSize() {\n    const isClient = typeof window === 'object';\n\n    const getSize = useCallback(function () {\n        return {\n            width: isClient ? window.innerWidth : undefined,\n            height: isClient ? window.innerHeight : undefined\n        };\n    }, [isClient])\n\n    const [windowSize, setWindowSize] = useState(getSize);\n\n    useEffect(() => {\n        if (!isClient) {\n            return false;\n        }\n\n        function handleResize() {\n            setWindowSize(getSize());\n        }\n\n        window.addEventListener('resize', handleResize);\n        return () => window.removeEventListener('resize', handleResize);\n    }, [getSize, isClient]); // Empty array ensures that effect is only run on mount and unmount\n\n    return windowSize;\n}\n\nexport default useWindowSize;\n","export const indexToCoord = (index, cols) => {\n    return {\n        x: index % cols,\n        y: Math.floor(index / cols)\n    }\n};\n\nexport const coordToIndex = ({x, y}, cols) => {\n    return y * cols + x;\n};\n\nexport const isDesolate = (board) => {\n    return board.every((cell) => cell === 0)\n};\n\nexport const mod = (x, m) => {\n    return (x % m + m) % m;\n};\n\n// calculate x or y coordinate of a neighbor given a diff and that dimension's size\n// This will wrap around the axis\nexport const calcNeighborCoordinate = (y, yd, yTotal) => {\n    return mod(y + yd, yTotal);\n};\n","import {useState} from \"react\";\nimport {calcNeighborCoordinate, coordToIndex, indexToCoord, isDesolate} from \"../util\"\n\nexport const addCols = (board, cCols, cRows, nCols) => {\n    const colsToAdd = nCols - cCols;\n\n    for (let i = 1; i <= cRows; i++) {\n        const newColsAdded = (i - 1) * colsToAdd;\n        const currentPosition = i * cCols;\n\n        board.splice(newColsAdded + currentPosition, 0, ...Array(colsToAdd).fill(0))\n    }\n\n    return board;\n};\n\nexport const removeCols = (board, cCols, cRows, nCols) => {\n    const colsToRemove = Math.abs(nCols - cCols);\n\n    for (let i = 1; i <= cRows; i++) {\n        const currentPosition = i * nCols;\n\n        board.splice(currentPosition, colsToRemove)\n    }\n\n    return board;\n};\n\nexport const addRows = (board, cCols, cRows, nRows) => {\n    const rowsToAdd = nRows - cRows;\n    return [...board, ...Array(rowsToAdd * cCols).fill(0)]\n};\n\nexport const removeRows = (board, cCols, cRows, nRows) => {\n    return board.slice(0, cCols * nRows)\n};\n\nexport const handleBoardDimensionChange = (board, cCols, cRows, nCols, nRows) => {\n    const colDiff = nCols - cCols;\n    const rowDiff = nRows - cRows;\n\n    let nBoard = [...board];\n\n    if (colDiff > 0) {\n        nBoard = addCols(board, cCols, cRows, nCols);\n    } else if (colDiff < 0) {\n        nBoard = removeCols(board, cCols, cRows, nCols);\n    }\n\n    if (rowDiff > 0) {\n        nBoard = addRows(nBoard, nCols, cRows, nRows);\n    } else if (rowDiff < 0) {\n        nBoard = removeRows(nBoard, nCols, cRows, nRows);\n    }\n\n    return nBoard;\n};\n\nexport const applyBrush = ({x, y}, board, bCols, bRows, brush) => {\n    // cache the distance vector\n    const brushDistanceVec = brush.distanceVec;\n    let nBoard = [...board];\n\n    for (let i = 0, l = brushDistanceVec.length; i < l; i++) {\n        // Only apply the alive cells to the board. This will let put\n        // irregular brushes closer together (like the glider)\n        if (brush.template[i] === 1) {\n            const [xd, yd] = brushDistanceVec[i];\n\n            const boardIndex = coordToIndex({\n                x: calcNeighborCoordinate(x, xd, bCols),\n                y: calcNeighborCoordinate(y, yd, bRows)\n            }, bCols);\n            nBoard[boardIndex] = brush.template[i];\n        }\n    }\n\n    return nBoard;\n};\n\nexport const getBoardWithAppliedBrushAndPaintedIndices = ({x, y}, board, bCols, bRows, brush) => {\n\n    const brushDistanceVec = brush.distanceVec;\n    let nBoard = [...board];\n    let paintedIndices = new Set();\n\n    for (let i = 0, l = brushDistanceVec.length; i < l; i++) {\n        // Only apply the alive cells to the board. This will let put\n        // irregular brushes closer together (like the glider)\n        if (brush.template[i] === 1) {\n            const [xd, yd] = brushDistanceVec[i];\n\n            const boardIndex = coordToIndex({\n                x: calcNeighborCoordinate(x, xd, bCols),\n                y: calcNeighborCoordinate(y, yd, bRows)\n            }, bCols);\n            nBoard[boardIndex] = brush.template[i];\n\n            paintedIndices.add(boardIndex);\n        }\n    }\n\n    return {\n        nBoard, paintedIndices\n    };\n};\n\n\nconst countNeighbors = ({x, y}, board, COLS, ROWS) => {\n    // hard coded for perf reasons\n    const neighborDiff = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n    let neighborCount = 0;\n\n    for (let [xd, yd] of neighborDiff) {\n        const xCoord2D = calcNeighborCoordinate(x, xd, COLS);\n        const yCoord2D = calcNeighborCoordinate(y, yd, ROWS);\n\n        if (board[coordToIndex({x: xCoord2D, y: yCoord2D}, COLS)] === 1) {\n            neighborCount += 1;\n        }\n    }\n    return neighborCount;\n};\n\nexport default function useBoard(rows, cols, seed) {\n    const [board, setBoard] = useState(seed);\n    const [isRunning, setIsRunning] = useState(false);\n\n    const advanceBoard = () => {\n        let newBoard = [...board];\n\n        for (let i = 0, boardLength = board.length; i < boardLength; i++) {\n            const coord = indexToCoord(i, cols);\n            const neighborCount = countNeighbors(coord, board, cols, rows);\n\n            if (board[i] === 1) {\n                if (neighborCount < 2 || neighborCount > 3) {\n                    newBoard[i] = 0;\n                }\n            } else {\n                if (neighborCount === 3) {\n                    newBoard[i] = 1;\n                }\n            }\n        }\n\n        setBoard(newBoard);\n\n        if (isDesolate(newBoard)) {\n            setIsRunning(false);\n        }\n    };\n\n    return [board, setBoard, isRunning, setIsRunning, advanceBoard]\n}\n","const addBrushName = (brush, patternString) => {\n    let searchIndex = 0;\n    const commentRegex = /#([CcNOPrR]).*/gm;\n    let comments = [];\n    let m;\n    let brushName;\n\n    while ((m = commentRegex.exec(patternString)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === commentRegex.lastIndex) {\n            commentRegex.lastIndex++;\n        }\n        comments.push(m[0]);\n        searchIndex = commentRegex.lastIndex\n    }\n    try {\n        brushName = comments[0].split(\"#N \")[1];\n        brush.name = brushName;\n        brush.displayName = brushName;\n\n        // skip the newline symbol\n        searchIndex++;\n        return searchIndex\n    } catch (e) {\n        console.log(e);\n        console.log(patternString)\n    }\n\n};\n\nconst addRowsAndCols = (brush, patternString, searchIndex) => {\n    let m;\n    const configRegex = /^x.+/gm;\n    configRegex.lastIndex = searchIndex;\n    let config = [];\n    while ((m = configRegex.exec(patternString)) !== null) {\n        if (m.index === configRegex.lastIndex) {\n            configRegex.lastIndex++;\n        }\n\n        config.push(m[0]);\n        searchIndex = configRegex.lastIndex\n    }\n\n    const [x, y] = config[0].split(\", \");\n    brush.cols = parseInt(x.split(\" = \")[1]);\n    brush.rows = parseInt(y.split(\" = \")[1]);\n\n    // skip the newline symbol\n    searchIndex++;\n    return searchIndex;\n};\n\nconst addTemplateToBrush = (brush, patternString, searchIndex) => {\n    const totalSize = brush.cols * brush.rows;\n    let template = new Uint8Array(totalSize);\n    let positionInTemplate = 0;\n\n    let count = 1,\n        in_number = false,\n        currentX = 0,\n        chr;\n\n    for (let len = patternString.length; searchIndex < len; searchIndex++) {\n        chr = patternString.charCodeAt(searchIndex);\n\n        if (chr >= 48 && chr <= 57) {\n            if (in_number) {\n                count *= 10;\n                count += chr ^ 48;\n            } else {\n                count = chr ^ 48;\n                in_number = true;\n            }\n        } else {\n            // b\n            if (chr === 98) {\n                // we can skip all these positions because we have 1D Uint8Array\n                // which is initialised to 0s\n                positionInTemplate += count;\n                currentX += count;\n                // A-Za-z\n            } else if ((chr >= 65 && chr <= 90) || (chr >= 97 && chr < 122)) {\n                currentX += count;\n                while (count--) {\n                    template[positionInTemplate] = 1;\n                    positionInTemplate++;\n                }\n            }\n            // $\n            else if (chr === 36) {\n                // we havent reached the end of cols, must skip ahead\n                if (currentX < brush.cols) {\n                    positionInTemplate += brush.cols - currentX;\n                }\n                // if we have a count at the end of line, we must skip\n                // couple of \"rows\"\n                if (count - 1) {\n                    positionInTemplate += (count - 1) * brush.cols\n                }\n                currentX = 0;\n            }\n            // !\n            else if (chr === 33) {\n                break;\n            }\n\n            // currentX = 0;\n            count = 1;\n            in_number = false;\n        }\n    }\n    brush.template = template;\n};\n\nexport async function parseRle(url) {\n    let response = await fetch(url);\n    const decoder = new TextDecoder(\"utf-8\");\n    const reader = response.body.getReader();\n    let rleFileString = '';\n    let brush = {};\n\n    while (true) {\n        const {done, value} = await reader.read();\n        if (done) {\n            break\n        }\n        rleFileString += decoder.decode(value);\n    }\n\n    let searchIndex = addBrushName(brush, rleFileString);\n    searchIndex = addRowsAndCols(brush, rleFileString, searchIndex);\n    addTemplateToBrush(brush, rleFileString, searchIndex);\n    return brush;\n}\n","import React, {useEffect, useState} from \"react\";\nimport {coordToIndex, indexToCoord} from \"../util\";\nimport {parseRle} from \"../parser/rle\";\n\n\nexport const centerCoord = ({rows, cols}) => {\n    return {\n        x: Math.floor((cols - 1) / 2),\n        y: Math.floor((rows - 1) / 2)\n    }\n};\n\nexport const brushDistanceVecFromCenter = ({rows, cols}) => {\n    const {x: bcx, y: bcy} = centerCoord({rows, cols});\n    let distanceVecsFromCenter = Array(rows * cols);\n\n    for (let i = 0, brushSize = rows * cols; i < brushSize; i++) {\n        let {x: cbpx, y: cbpy} = indexToCoord(i, cols);\n\n        distanceVecsFromCenter[i] = [cbpx - bcx, cbpy - bcy]\n    }\n\n    return distanceVecsFromCenter;\n};\n\nexport const rotateTemplate90deg = ({template, rows, cols}) => {\n    let rotatedTemplate = Array(rows * cols);\n    let i = 0;\n\n    for (let x = cols - 1; x >= 0; x--) {\n        for (let y = 0; y < rows; y++) {\n            const index = coordToIndex({x, y}, cols);\n            rotatedTemplate[i] = template[index];\n            i++\n        }\n    }\n\n    return {\n        template: rotatedTemplate,\n        rows: cols,\n        cols: rows\n    }\n};\n\nexport const rotateBrush90deg = (brush) => {\n    const newTemplate = rotateTemplate90deg(brush);\n    return {\n        ...brush,\n        ...newTemplate,\n        distanceVec: brushDistanceVecFromCenter(newTemplate)\n    }\n};\n\nexport const defaultBrush = {\n    name: \"Glider\",\n    displayName: \"Glider\",\n    rows: 3,\n    cols: 3,\n    template: [\n        0, 1, 0,\n        0, 0, 1,\n        1, 1, 1\n    ],\n    distanceVec: brushDistanceVecFromCenter({cols: 3, rows: 3})\n};\n\nexport const getBrush = (name, brushes) => {\n    let b = brushes.filter(brush => brush.name === name)[0];\n    b.distanceVec = brushDistanceVecFromCenter(b);\n    return b;\n};\n\nconst brushList = [\n    \"bigun.rle\",\n    \"crab.rle\",\n    \"glider.rle\",\n    \"glidertrain.rle\",\n    \"gosperglider.rle\",\n    \"hwss.rle\",\n    \"inlineinverter.rle\",\n    \"jaydot.rle\",\n    \"loafer.rle\",\n    \"lobster.rle\",\n    \"newgun2.rle\",\n    \"nms.rle\",\n    \"pixel.rle\",\n    \"rabbits.rle\",\n    \"simkinglider.rle\",\n    \"spacerake.rle\",\n    \"spider.rle\",\n    \"twogun.rle\",\n    \"wing.rle\",\n];\n\nexport function useBrushes(cols, rows) {\n    const [brushes, setBrushes] = useState([]);\n    const [loaded, setLoaded] = useState(false);\n    const [filteredBrushes, setFilteredBrushes] = useState([]);\n\n    useEffect(() => {\n        Promise.all(brushList.map(brush => parseRle(process.env.PUBLIC_URL + \"/patterns/\" + brush)))\n            .then(vals => {\n                setLoaded(true);\n                setBrushes(vals);\n            });\n    }, []);\n\n    useEffect(() => {\n        const smallerThanBoard = brushes.filter(brush => brush.cols <= cols && brush.rows <= rows)\n        setFilteredBrushes(smallerThanBoard);\n    }, [cols, rows, brushes]);\n\n    return [filteredBrushes, loaded];\n}\n\nexport function BrushSelector({onChange, selectedBrush, brushesLoaded, brushes}) {\n    if (brushesLoaded) {\n        return (\n            <select\n                className=\"select\"\n                value={selectedBrush.name} onChange={onChange}>\n                {brushes.map(brush => {\n                    return (\n                        <option key={brush.name} value={brush.name}>\n                            {brush.displayName}\n                        </option>\n                    )\n                })}\n            </select>\n        )\n    } else {\n        return <div>loading</div>\n    }\n}\n","import React, {useCallback, useEffect} from \"react\";\nimport {BrushSelector, getBrush, rotateBrush90deg, useBrushes} from \"./Brushes\";\n\nexport default function Controls({advanceBoard, toggleIsRunning, isRunning, setIsRunning, setBoard, board, setSelectedBrushWrapper, selectedBrush, touchHoverClear, setLastPaintedIndices, cols, rows}) {\n    const [brushes, brushesLoaded] = useBrushes(cols, rows);\n\n    const memoBoardReset = useCallback((event) => {\n        if (event.code === \"KeyE\" || event.type === \"click\") {\n            setIsRunning(false);\n            setBoard([...board].fill(0))\n            setLastPaintedIndices(new Set())\n        }\n    }, [setIsRunning, setBoard, board, setLastPaintedIndices]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoBoardReset, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoBoardReset, false)\n        };\n    }, [memoBoardReset]);\n\n    const memoNext = useCallback((event) => {\n        if (event.code === \"KeyW\" || event.type === \"click\") {\n            setLastPaintedIndices(new Set());\n            setIsRunning(false);\n            advanceBoard();\n        }\n    }, [setIsRunning, advanceBoard, setLastPaintedIndices]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoNext, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoNext, false)\n        };\n    }, [memoNext]);\n\n    return (\n        <div className=\"controls\">\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={() => {\n                    setIsRunning(false);\n                    advanceBoard()\n                }}>\n                Next <span className=\"button__shortcut\">[<span className=\"shift\">⇧</span>+w]</span>\n            </button>\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={toggleIsRunning}>\n                {isRunning ? \"Stop \" : \"Start \"}\n                <span className=\"button__shortcut\">[space]</span>\n            </button>\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={memoBoardReset}>\n                Reset\n                <span className=\"button__shortcut\">[<span className=\"shift\">⇧</span>+e]</span>\n            </button>\n            <button\n                className=\"button button--mobile\"\n                onClick={() => {\n                    setSelectedBrushWrapper(rotateBrush90deg(selectedBrush))\n                }}>\n                Rotate 90deg\n                <span className=\"button__shortcut\">[<span className=\"shift\">⇧</span>+r]</span>\n            </button>\n            <BrushSelector\n                onChange={e => {\n                    setSelectedBrushWrapper(getBrush(e.target.value, brushes))\n                    e.target.blur()\n                }}\n                selectedBrush={selectedBrush}\n                brushesLoaded={brushesLoaded}\n                brushes={brushes}\n            />\n            <button\n                className=\"button button--desktop\"\n                onClick={() => {\n                    setSelectedBrushWrapper(rotateBrush90deg(selectedBrush))\n                }}>\n                Rotate 90deg\n                <span className=\"button__shortcut\">[<span className=\"shift\">⇧</span>+r]</span>\n            </button>\n        </div>\n    );\n}\n","import React, {useRef, Fragment, useEffect, useState, useCallback} from 'react';\nimport useInterval from \"./hooks/useInterval\";\nimport './App.scss';\nimport useWindowSize from \"./hooks/useWindowSize\";\nimport useBoard, {\n    getBoardWithAppliedBrushAndPaintedIndices,\n    handleBoardDimensionChange\n} from \"./hooks/useBoard\";\nimport {indexToCoord} from \"./util\"\nimport {defaultBrush, rotateBrush90deg} from \"./components/Brushes\";\nimport Controls from \"./components/Controls\";\n\nconst INTERVAL = 50;\nconst CELLSIZE = 15;\nconst gridGap = 1;\nlet lastHoverCoord;\n\nconst mousePosToCoord = (eX, eY) => {\n    const x = Math.floor(eX / (CELLSIZE + gridGap));\n    const y = Math.floor(eY / (CELLSIZE + gridGap));\n    return {x, y};\n};\n\nconst intersection = (setA, setB) => {\n    let _intersection = new Set()\n    for (let elem of setB) {\n        if (setA.has(elem)) {\n            _intersection.add(elem)\n        }\n    }\n    return _intersection\n};\n\nfunction CanvasBoard({board, windowSize, cols, rows, setBoard, setCols, setRows, brush, setHoverBoard, hoverBoard, seed, lastPaintedHoverIndices, lastPaintedIndices, setLastPaintedHoverIndices, setLastPaintedIndices, isRunning}) {\n    const canvasRef = useRef(null);\n\n    const clearCanvas = (ctx) => {\n        ctx.clearRect(0, 0, windowSize.width, windowSize.height);\n    };\n\n    const drawCell = (ctx, cell, index, cols) => {\n        const {x, y} = indexToCoord(index, cols);\n        ctx.fillStyle = cell === 1 ? \"#00adb5\" : \"#393e46\";\n        ctx.fillRect(x * CELLSIZE + x, y * CELLSIZE + y, CELLSIZE, CELLSIZE)\n    };\n\n    const drawHoverCell = (ctx, cell, index, cols) => {\n        // draws only the alive cell in the template\n        // paints the cell only if it has beeb set to be hovered\n        if (cell === 1 && (isRunning || lastPaintedHoverIndices.has(index))) {\n            const {x, y} = indexToCoord(index, cols);\n            ctx.fillStyle = lastPaintedIndices.has(index) ? \"rgb(200,87,125)\" : \"rgba(238, 238, 238, 0.3)\";\n            ctx.fillRect(x * CELLSIZE + x, y * CELLSIZE + y, CELLSIZE, CELLSIZE)\n        }\n    };\n\n    useEffect(() => {\n        const newRows = Math.floor((windowSize.height + gridGap) / (CELLSIZE + gridGap));\n        const newCols = Math.floor((windowSize.width + gridGap) / (CELLSIZE + gridGap));\n        if (cols !== newCols || rows !== newRows) {\n            setBoard(handleBoardDimensionChange(board, cols, rows, newCols, newRows));\n            setRows(newRows);\n            setCols(newCols);\n        }\n    });\n\n    useEffect(() => {\n        const ctx = canvasRef.current.getContext(\"2d\");\n        clearCanvas(ctx);\n        for (let i = 0, boardLength = board.length; i < boardLength; i++) {\n            drawCell(ctx, board[i], i, cols);\n            drawHoverCell(ctx, hoverBoard[i], i, cols)\n        }\n    });\n\n    return (\n        <canvas\n            ref={canvasRef}\n            width={windowSize.width}\n            height={windowSize.height}\n            onClick={e => {\n                if (isRunning || intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0) {\n                    const cCoord = mousePosToCoord(e.pageX, e.pageY);\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(cCoord, board, cols, rows, brush)\n\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n            }}\n            onMouseLeave={() => setHoverBoard(seed)}\n            onTouchEnd={e => {\n                lastHoverCoord = mousePosToCoord(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n                if (isRunning || intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0) {\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush)\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n                setHoverBoard(seed);\n                e.preventDefault()\n            }}\n            onTouchMove={(e) => {\n                lastHoverCoord = mousePosToCoord(e.touches[0].clientX, e.touches[0].clientY);\n                const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, brush);\n                setLastPaintedHoverIndices(paintedIndices);\n                if (isRunning) {\n                    setLastPaintedHoverIndices(new Set());\n                } else {\n                    setLastPaintedHoverIndices(paintedIndices);\n                }\n                setHoverBoard(nBoard);\n                // allow dragging and placing smaller brushes like gliders and pixels\n                if ((brush.template.length < 17 &&\n                    (isRunning || intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0))) {\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush)\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n            }}\n            onMouseMove={(e) => {\n                lastHoverCoord = mousePosToCoord(e.pageX, e.pageY);\n\n                const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, brush);\n\n                if (isRunning) {\n                    setLastPaintedHoverIndices(new Set());\n                } else {\n                    setLastPaintedHoverIndices(paintedIndices);\n                }\n                setHoverBoard(nBoard);\n\n                if (e.buttons === 1 || e.buttons === 3) {\n                    if (isRunning ||\n                        intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0) {\n                        const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush);\n                        if (isRunning) {\n                            setLastPaintedIndices(new Set());\n                        } else {\n                            setLastPaintedIndices(paintedIndices);\n                        }\n                        setBoard(nBoard)\n                    }\n                }\n            }}\n        />\n    );\n}\n\nfunction BoardWrapper({cols, rows, seed, windowSize, setRows, setCols}) {\n    const [hoverBoard, setHoverBoard] = useBoard(rows, cols, seed);\n    const [board, setBoard, isRunning, setIsRunning, advanceBoard] = useBoard(rows, cols, seed);\n    const [selectedBrush, setSelectedBrush] = useState(defaultBrush);\n    const [lastPaintedIndices, setLastPaintedIndices] = useState(new Set());\n    const [lastPaintedHoverIndices, setLastPaintedHoverIndices] = useState(new Set());\n\n    useInterval(advanceBoard, isRunning ? INTERVAL : null);\n\n    const setSelectedBrushCb = useCallback((newBrush) => {\n        setSelectedBrush(newBrush);\n    }, [setSelectedBrush]);\n\n    const toggleIsRunning = useCallback((event) => {\n        if (event.keyCode === 32 || event.type === \"click\") {\n            setLastPaintedIndices(new Set());\n            setIsRunning(!isRunning);\n        }\n    }, [isRunning, setIsRunning, setLastPaintedIndices]);\n\n    const touchHoverClear = useCallback(() => {\n        setHoverBoard(seed);\n    }, [setHoverBoard, seed]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", toggleIsRunning, false);\n        return () => {\n            document.removeEventListener(\"keydown\", toggleIsRunning, false)\n        };\n    }, [toggleIsRunning]);\n\n    const memoRotateBrush = useCallback((event) => {\n        if (event.code === \"KeyR\") {\n            setSelectedBrushCb(rotateBrush90deg(selectedBrush));\n            const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, rotateBrush90deg(selectedBrush));\n            setLastPaintedHoverIndices(paintedIndices);\n            setHoverBoard(nBoard);\n        }\n    }, [setSelectedBrushCb, selectedBrush, seed, cols, rows, setHoverBoard]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoRotateBrush, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoRotateBrush, false)\n        };\n    }, [memoRotateBrush]);\n\n    return (\n        <Fragment>\n            <CanvasBoard board={board}\n                         brush={selectedBrush}\n                         setBoard={setBoard}\n                         windowSize={windowSize}\n                         cols={cols}\n                         setCols={setCols}\n                         setRows={setRows}\n                         rows={rows}\n                         seed={seed}\n                         setHoverBoard={setHoverBoard}\n                         hoverBoard={hoverBoard}\n                         lastPaintedIndices={lastPaintedIndices}\n                         setLastPaintedIndices={setLastPaintedIndices}\n                         lastPaintedHoverIndices={lastPaintedHoverIndices}\n                         isRunning={isRunning}\n                         setLastPaintedHoverIndices={setLastPaintedHoverIndices}\n            />\n            <Controls advanceBoard={advanceBoard}\n                      toggleIsRunning={toggleIsRunning}\n                      isRunning={isRunning}\n                      setIsRunning={setIsRunning}\n                      setBoard={setBoard}\n                      board={board}\n                      touchHoverClear={touchHoverClear}\n                      setSelectedBrushWrapper={setSelectedBrushCb}\n                      selectedBrush={selectedBrush}\n                      setLastPaintedIndices={setLastPaintedIndices}\n                      cols={cols}\n                      rows={rows}/>\n        </Fragment>\n    )\n}\n\nfunction App() {\n    const windowSize = useWindowSize();\n    // defaultBrush.distanceVec = brushDistanceVecFromCenter(defaultBrush);\n    const [rows, setRows] = useState(Math.floor((windowSize.height + gridGap) / (CELLSIZE + gridGap)));\n    const [cols, setCols] = useState(Math.floor((windowSize.width + gridGap) / (CELLSIZE + gridGap)));\n    const seed = Array(rows * cols).fill(0);\n\n    return (\n        <BoardWrapper rows={rows} cols={cols} seed={seed} windowSize={windowSize} setRows={setRows} setCols={setCols}/>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}