{"version":3,"sources":["hooks/useInterval.js","hooks/useWindowSize.js","util.js","hooks/useBoard.js","components/Brushes.js","components/Controls.js","components/ContextMenu.js","components/BrushHud.js","parser/rle.js","hooks/useBrushes.js","App.js","serviceWorker.js","index.js"],"names":["useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","useWindowSize","isClient","window","getSize","useCallback","width","innerWidth","undefined","height","innerHeight","useState","windowSize","setWindowSize","handleResize","addEventListener","removeEventListener","indexToCoord","index","cols","x","y","Math","floor","coordToIndex","calcNeighborCoordinate","yd","yTotal","m","handleBoardDimensionChange","board","cCols","cRows","nCols","nRows","colDiff","rowDiff","nBoard","colsToAdd","i","newColsAdded","currentPosition","splice","Array","fill","addCols","colsToRemove","abs","removeCols","rowsToAdd","addRows","slice","removeRows","getBoardWithAppliedBrushAndPaintedIndices","bCols","bRows","brush","brushDistanceVec","distanceVec","paintedIndices","Set","l","length","template","xd","boardIndex","add","countNeighbors","COLS","ROWS","neighborCount","xCoord2D","yCoord2D","useBoard","rows","seed","setBoard","isRunning","setIsRunning","newBoard","boardLength","coord","every","cell","isDesolate","centerCoord","brushDistanceVecFromCenter","bcx","bcy","distanceVecsFromCenter","brushSize","cbpx","cbpy","rotateBrush90deg","newTemplate","rotatedTemplate","rotateTemplate90deg","defaultBrush","name","displayName","BrushSelector","onChange","selectedBrush","brushesLoaded","brushes","className","value","map","key","Controls","advanceBoard","toggleIsRunning","setSelectedBrushWrapper","touchHoverClear","setLastPaintedIndices","memoBoardReset","event","code","type","document","memoNext","onTouchStart","onClick","e","b","filter","getBrush","target","blur","ContextMenu","contextMenuRef","children","isOpen","clickPosition","onBodyClick","transformY","openUp","transformX","openRight","ref","style","left","top","transform","BrushOption","React","memo","onBrushSelect","isSelected","canvasRef","getPreviewDimensions","cellSize","aBrush","applyBrush","drawCell","ctx","fillStyle","fillRect","getContext","BrushHud","wrapperRef","setIsOpen","setClickPosition","setOpenUp","setOpenRight","usesTouch","setUsesTouch","contextHandler","preventDefault","dimensions","getBoundingClientRect","clientX","clientY","touchHandler","useBrushContextMenu","brushesLoading","brushlist","newBrush","addBrushName","patternString","brushName","searchIndex","commentRegex","comments","exec","lastIndex","push","split","console","log","addRowsAndCols","configRegex","config","parseInt","addTemplateToBrush","chr","totalSize","Uint8Array","positionInTemplate","count","in_number","currentX","len","charCodeAt","url","a","fetch","response","decoder","TextDecoder","reader","body","getReader","rleFileString","read","done","decode","brushList","useBrushes","setBrushes","loaded","setLoaded","filteredBrushes","setFilteredBrushes","Promise","all","parseRle","process","then","vals","smallerThanBoard","lastHoverCoord","mousePosToCoord","eX","eY","intersection","setA","setB","_intersection","elem","has","touchMoved","CanvasBoard","setCols","setRows","setHoverBoard","hoverBoard","lastPaintedHoverIndices","lastPaintedIndices","setLastPaintedHoverIndices","lastMouseDownIndex","setLastMouseDownIndex","drawHoverCell","newRows","newCols","clearRect","clearCanvas","size","cCoord","pageX","pageY","onMouseLeave","onTouchEnd","changedTouches","onTouchMove","touches","onMouseMove","buttons","BoardWrapper","setSelectedBrush","setSelectedBrushCb","keyCode","memoRotateBrush","App","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.98809288.chunk.js","sourcesContent":["import {useEffect, useRef} from \"react\";\n\n\nfunction useInterval(callback, delay) {\n    const savedCallback = useRef();\n\n    // Remember the latest callback.\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval.\n    useEffect(() => {\n        function tick() {\n            savedCallback.current();\n        }\n\n        if (delay !== null) {\n            let id = setInterval(tick, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}\n\nexport default useInterval;\n","import {useState, useEffect, useCallback} from 'react';\n\n// Hook\nfunction useWindowSize() {\n    const isClient = typeof window === 'object';\n\n    const getSize = useCallback(function () {\n        return {\n            width: isClient ? window.innerWidth : undefined,\n            height: isClient ? window.innerHeight : undefined\n        };\n    }, [isClient])\n\n    const [windowSize, setWindowSize] = useState(getSize);\n\n    useEffect(() => {\n        if (!isClient) {\n            return false;\n        }\n\n        function handleResize() {\n            setWindowSize(getSize());\n        }\n\n        window.addEventListener('resize', handleResize);\n        return () => window.removeEventListener('resize', handleResize);\n    }, [getSize, isClient]); // Empty array ensures that effect is only run on mount and unmount\n\n    return windowSize;\n}\n\nexport default useWindowSize;\n","export const indexToCoord = (index, cols) => {\n    return {\n        x: index % cols,\n        y: Math.floor(index / cols)\n    }\n};\n\nexport const coordToIndex = ({x, y}, cols) => {\n    return y * cols + x;\n};\n\nexport const isDesolate = (board) => {\n    return board.every((cell) => cell === 0)\n};\n\nexport const mod = (x, m) => {\n    return (x % m + m) % m;\n};\n\n// calculate x or y coordinate of a neighbor given a diff and that dimension's size\n// This will wrap around the axis\nexport const calcNeighborCoordinate = (y, yd, yTotal) => {\n    return mod(y + yd, yTotal);\n};\n","import {useState} from \"react\";\nimport {calcNeighborCoordinate, coordToIndex, indexToCoord, isDesolate} from \"../util\"\n\nexport const addCols = (board, cCols, cRows, nCols) => {\n    const colsToAdd = nCols - cCols;\n\n    for (let i = 1; i <= cRows; i++) {\n        const newColsAdded = (i - 1) * colsToAdd;\n        const currentPosition = i * cCols;\n\n        board.splice(newColsAdded + currentPosition, 0, ...Array(colsToAdd).fill(0))\n    }\n\n    return board;\n};\n\nexport const removeCols = (board, cCols, cRows, nCols) => {\n    const colsToRemove = Math.abs(nCols - cCols);\n\n    for (let i = 1; i <= cRows; i++) {\n        const currentPosition = i * nCols;\n\n        board.splice(currentPosition, colsToRemove)\n    }\n\n    return board;\n};\n\nexport const addRows = (board, cCols, cRows, nRows) => {\n    const rowsToAdd = nRows - cRows;\n    return [...board, ...Array(rowsToAdd * cCols).fill(0)]\n};\n\nexport const removeRows = (board, cCols, cRows, nRows) => {\n    return board.slice(0, cCols * nRows)\n};\n\nexport const handleBoardDimensionChange = (board, cCols, cRows, nCols, nRows) => {\n    const colDiff = nCols - cCols;\n    const rowDiff = nRows - cRows;\n\n    let nBoard = [...board];\n\n    if (colDiff > 0) {\n        nBoard = addCols(board, cCols, cRows, nCols);\n    } else if (colDiff < 0) {\n        nBoard = removeCols(board, cCols, cRows, nCols);\n    }\n\n    if (rowDiff > 0) {\n        nBoard = addRows(nBoard, nCols, cRows, nRows);\n    } else if (rowDiff < 0) {\n        nBoard = removeRows(nBoard, nCols, cRows, nRows);\n    }\n\n    return nBoard;\n};\n\nexport const applyBrush = ({x, y}, board, bCols, bRows, brush) => {\n    // cache the distance vector\n    const brushDistanceVec = brush.distanceVec;\n    let nBoard = [...board];\n\n    for (let i = 0, l = brushDistanceVec.length; i < l; i++) {\n        // Only apply the alive cells to the board. This will let put\n        // irregular brushes closer together (like the glider)\n        if (brush.template[i] === 1) {\n            const [xd, yd] = brushDistanceVec[i];\n\n            const boardIndex = coordToIndex({\n                x: calcNeighborCoordinate(x, xd, bCols),\n                y: calcNeighborCoordinate(y, yd, bRows)\n            }, bCols);\n            nBoard[boardIndex] = brush.template[i];\n        }\n    }\n\n    return nBoard;\n};\n\nexport const getBoardWithAppliedBrushAndPaintedIndices = ({x, y}, board, bCols, bRows, brush) => {\n\n    const brushDistanceVec = brush.distanceVec;\n    let nBoard = [...board];\n    let paintedIndices = new Set();\n\n    for (let i = 0, l = brushDistanceVec.length; i < l; i++) {\n        // Only apply the alive cells to the board. This will let put\n        // irregular brushes closer together (like the glider)\n        if (brush.template[i] === 1) {\n            const [xd, yd] = brushDistanceVec[i];\n\n            const boardIndex = coordToIndex({\n                x: calcNeighborCoordinate(x, xd, bCols),\n                y: calcNeighborCoordinate(y, yd, bRows)\n            }, bCols);\n            nBoard[boardIndex] = brush.template[i];\n\n            paintedIndices.add(boardIndex);\n        }\n    }\n\n    return {\n        nBoard, paintedIndices\n    };\n};\n\n\nconst countNeighbors = ({x, y}, board, COLS, ROWS) => {\n    // hard coded for perf reasons\n    const neighborDiff = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n    let neighborCount = 0;\n\n    for (let [xd, yd] of neighborDiff) {\n        const xCoord2D = calcNeighborCoordinate(x, xd, COLS);\n        const yCoord2D = calcNeighborCoordinate(y, yd, ROWS);\n\n        if (board[coordToIndex({x: xCoord2D, y: yCoord2D}, COLS)] === 1) {\n            neighborCount += 1;\n        }\n    }\n    return neighborCount;\n};\n\nexport default function useBoard(rows, cols, seed) {\n    const [board, setBoard] = useState(seed);\n    const [isRunning, setIsRunning] = useState(false);\n\n    const advanceBoard = () => {\n        let newBoard = [...board];\n\n        for (let i = 0, boardLength = board.length; i < boardLength; i++) {\n            const coord = indexToCoord(i, cols);\n            const neighborCount = countNeighbors(coord, board, cols, rows);\n\n            if (board[i] === 1) {\n                if (neighborCount < 2 || neighborCount > 3) {\n                    newBoard[i] = 0;\n                }\n            } else {\n                if (neighborCount === 3) {\n                    newBoard[i] = 1;\n                }\n            }\n        }\n\n        setBoard(newBoard);\n\n        if (isDesolate(newBoard)) {\n            setIsRunning(false);\n        }\n    };\n\n    return [board, setBoard, isRunning, setIsRunning, advanceBoard]\n}\n","import React from \"react\";\nimport {coordToIndex, indexToCoord} from \"../util\";\n\nexport const centerCoord = ({rows, cols}) => {\n    return {\n        x: Math.floor((cols - 1) / 2),\n        y: Math.floor((rows - 1) / 2)\n    }\n};\n\nexport const brushDistanceVecFromCenter = ({rows, cols}) => {\n    const {x: bcx, y: bcy} = centerCoord({rows, cols});\n    let distanceVecsFromCenter = Array(rows * cols);\n\n    for (let i = 0, brushSize = rows * cols; i < brushSize; i++) {\n        let {x: cbpx, y: cbpy} = indexToCoord(i, cols);\n\n        distanceVecsFromCenter[i] = [cbpx - bcx, cbpy - bcy]\n    }\n\n    return distanceVecsFromCenter;\n};\n\nexport const rotateTemplate90deg = ({template, rows, cols}) => {\n    let rotatedTemplate = Array(rows * cols);\n    let i = 0;\n\n    for (let x = cols - 1; x >= 0; x--) {\n        for (let y = 0; y < rows; y++) {\n            const index = coordToIndex({x, y}, cols);\n            rotatedTemplate[i] = template[index];\n            i++\n        }\n    }\n\n    return {\n        template: rotatedTemplate,\n        rows: cols,\n        cols: rows\n    }\n};\n\nexport const rotateBrush90deg = (brush) => {\n    const newTemplate = rotateTemplate90deg(brush);\n    return {\n        ...brush,\n        ...newTemplate,\n        distanceVec: brushDistanceVecFromCenter(newTemplate)\n    }\n};\n\nexport const defaultBrush = {\n    name: \"Glider\",\n    displayName: \"Glider\",\n    rows: 3,\n    cols: 3,\n    template: [\n        0, 1, 0,\n        0, 0, 1,\n        1, 1, 1\n    ],\n    distanceVec: brushDistanceVecFromCenter({cols: 3, rows: 3})\n};\n\nexport const getBrush = (name, brushes) => {\n    let b = brushes.filter(brush => brush.name === name)[0];\n    b.distanceVec = brushDistanceVecFromCenter(b);\n    return b;\n};\n\n\n\nexport function BrushSelector({onChange, selectedBrush, brushesLoaded, brushes}) {\n    if (brushesLoaded) {\n        return (\n            <select\n                className=\"select\"\n                value={selectedBrush.name} onChange={onChange}>\n                {brushes.map(brush => {\n                    return (\n                        <option key={brush.name} value={brush.name}>\n                            {brush.displayName}\n                        </option>\n                    )\n                })}\n            </select>\n        )\n    } else {\n        return <div>loading</div>\n    }\n}\n","import React, {useCallback, useEffect} from \"react\";\nimport {BrushSelector, getBrush, rotateBrush90deg} from \"./Brushes\";\n\nexport default function Controls({advanceBoard, toggleIsRunning, isRunning, setIsRunning, setBoard, board, setSelectedBrushWrapper, selectedBrush, touchHoverClear, setLastPaintedIndices, brushes, brushesLoaded}) {\n\n    const memoBoardReset = useCallback((event) => {\n        if (event.code === \"KeyE\" || event.type === \"click\") {\n            setIsRunning(false);\n            setBoard([...board].fill(0))\n            setLastPaintedIndices(new Set())\n        }\n    }, [setIsRunning, setBoard, board, setLastPaintedIndices]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoBoardReset, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoBoardReset, false)\n        };\n    }, [memoBoardReset]);\n\n    const memoNext = useCallback((event) => {\n        if (event.code === \"KeyW\" || event.type === \"click\") {\n            setLastPaintedIndices(new Set());\n            setIsRunning(false);\n            advanceBoard();\n        }\n    }, [setIsRunning, advanceBoard, setLastPaintedIndices]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoNext, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoNext, false)\n        };\n    }, [memoNext]);\n\n    return (\n        <div className=\"controls\">\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={() => {\n                    setIsRunning(false);\n                    advanceBoard()\n                }}>\n                Next <span className=\"button__shortcut\">[w]</span>\n            </button>\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={toggleIsRunning}>\n                {isRunning ? \"Stop \" : \"Start \"}\n                <span className=\"button__shortcut\">[space]</span>\n            </button>\n            <button\n                className=\"button\"\n                onTouchStart={touchHoverClear}\n                onClick={memoBoardReset}>\n                Empty\n                <span className=\"button__shortcut\"> [e]</span>\n            </button>\n            <button\n                className=\"button button--mobile\"\n                onClick={() => {\n                    setSelectedBrushWrapper(rotateBrush90deg(selectedBrush))\n                }}>\n                Rotate 90deg\n            </button>\n            <BrushSelector\n                onChange={e => {\n                    setSelectedBrushWrapper(getBrush(e.target.value, brushes))\n                    e.target.blur()\n                }}\n                selectedBrush={selectedBrush}\n                brushesLoaded={brushesLoaded}\n                brushes={brushes}\n            />\n            <button\n                className=\"button button--desktop\"\n                onClick={() => {\n                    setSelectedBrushWrapper(rotateBrush90deg(selectedBrush))\n                }}>\n                Rotate 90deg\n                <span className=\"button__shortcut\"> [r]</span>\n            </button>\n        </div>\n    );\n}\n","import React, {useCallback, useEffect, useState} from \"react\";\n\nexport function useBrushContextMenu(wrapperRef, contextMenuRef) {\n    const [isOpen, setIsOpen] = useState(false);\n    const [clickPosition, setClickPosition] = useState({x: 0, y: 0});\n    const [openUp, setOpenUp] = useState(false);\n    const [openRight, setOpenRight] = useState(false);\n    const [usesTouch, setUsesTouch] = useState(false);\n\n    const contextHandler = useCallback((event) => {\n        if (usesTouch) {\n            return;\n        }\n        event.preventDefault();\n\n        const menu = contextMenuRef.current;\n        const dimensions = menu.getBoundingClientRect();\n\n        let x = event.clientX;\n        let y = event.clientY;\n\n        if (x + dimensions.width > window.innerWidth) {\n            setOpenRight(true);\n        } else {\n            setOpenRight(false);\n        }\n        if (y + dimensions.height > window.innerHeight) {\n            setOpenUp(true);\n        } else {\n            setOpenUp(false);\n        }\n\n        setClickPosition({x, y});\n        setIsOpen(true)\n\n\n    }, [setIsOpen, setClickPosition, setOpenUp, setOpenRight, contextMenuRef, usesTouch]);\n\n    const touchHandler = useCallback((event) => {\n        setUsesTouch(true);\n    }, [setUsesTouch]);\n\n\n    useEffect(() => {\n        const ref = wrapperRef.current;\n\n        ref.addEventListener(\"contextmenu\", contextHandler, false);\n        ref.addEventListener(\"touchstart\", touchHandler, false);\n        return () => {\n            ref.removeEventListener(\"contextmenu\", contextHandler, false);\n            ref.removeEventListener(\"touchstart\", touchHandler, false);\n        };\n    }, [wrapperRef, contextHandler, touchHandler]);\n\n    return [clickPosition, isOpen, setIsOpen, openUp, openRight]\n}\n\n\nexport function ContextMenu({contextMenuRef, children, isOpen, clickPosition, onBodyClick, openUp, openRight}) {\n    const transformY = openUp ? \"-100%\" : \"0\";\n    const transformX = openRight ? \"-100%\" : \"0\";\n\n    return (\n        <div className={`context-menu-wrapper ${isOpen}`}\n             onClick={onBodyClick}>\n            <div ref={contextMenuRef}\n                 style={{\n                     left: clickPosition.x,\n                     top: clickPosition.y,\n                     transform: `translate(${transformX}, ${transformY})`\n                 }}\n                 className={`context-menu `}>\n                {children}\n            </div>\n        </div>\n    )\n}\n","import React, {useEffect, useRef} from \"react\";\nimport {ContextMenu, useBrushContextMenu} from \"./ContextMenu\";\nimport {indexToCoord} from \"../util\";\nimport {applyBrush} from \"../hooks/useBoard\";\nimport {brushDistanceVecFromCenter, centerCoord} from \"./Brushes\";\n\nconst bcwidth = 300;\nconst bcheight = 150;\nconst gap = 1;\n\n// calculates board size for given template so\n// board stays to 2x1 dimensions and the brush is\n// still kinda centered\nconst getPreviewDimensions = ({cols, rows}) => {\n    if (rows >= cols) {\n        return {\n            rows: rows,\n            cols: rows * 2\n        }\n    } else {\n        if (rows * 2 > cols) {\n            return {\n                rows: rows,\n                cols: rows * 2\n            }\n        } else {\n            if (cols % 2 === 0) {\n                return {\n                    cols: cols,\n                    rows: cols / 2\n                }\n            } else {\n                return {\n                    cols: cols + 1,\n                    rows: (cols + 1) / 2\n                }\n\n            }\n        }\n    }\n};\n\nconst BrushOption = React.memo(({brush, onBrushSelect, isSelected}) => {\n    const canvasRef = useRef(null);\n\n    const {cols, rows} = getPreviewDimensions(brush);\n\n    const cellSize = ((bcwidth + gap) / cols) - gap;\n    let aBrush = {\n        ...brush,\n        distanceVec: brushDistanceVecFromCenter(brush)\n    };\n    let board = Array(rows * cols).fill(0);\n\n    board = applyBrush(centerCoord({cols, rows}), board, cols, rows, aBrush);\n\n    const drawCell = (ctx, cell, index, cols) => {\n        const {x, y} = indexToCoord(index, cols);\n        ctx.fillStyle = cell === 1 ? \"#00adb5\" : \"#393e46\";\n        ctx.fillRect(x * cellSize + x, y * cellSize + y, cellSize, cellSize)\n    };\n\n    useEffect(() => {\n        const ctx = canvasRef.current.getContext(\"2d\");\n        for (let i = 0, boardLength = board.length; i < boardLength; i++) {\n            drawCell(ctx, board[i], i, cols);\n        }\n    });\n\n    return (\n        <div onClick={e => onBrushSelect(aBrush)}\n             className={`brush-option ${isSelected ? \"brush-option--selected\" : \"\"}`}>\n            <canvas\n                className=\"brush-option__canvas\"\n                style={{width: bcwidth, height: bcheight}}\n                ref={canvasRef}/>\n            <div className=\"brush-option__title\">\n                {brush.displayName}\n            </div>\n        </div>\n    )\n});\n\nexport const BrushHud = React.memo(({wrapperRef, brushes, brushesLoaded, onBrushSelect, selectedBrush}) => {\n\n    const contextMenuRef = useRef(null);\n    const [clickPosition, isOpen, setIsOpen, openUp, openRight] = useBrushContextMenu(wrapperRef, contextMenuRef);\n\n    const brushesLoading = <div className=\"brush-hud__loading\">Loading</div>\n    const brushlist = brushes.map(brush => <BrushOption key={brush.name}\n                                                        brush={brush}\n                                                        isSelected={selectedBrush.name === brush.name}\n                                                        onBrushSelect={(newBrush) => {\n                                                            onBrushSelect(newBrush);\n                                                            setIsOpen(false);\n                                                        }}/>)\n    return (\n        <ContextMenu contextMenuRef={contextMenuRef}\n                     onBodyClick={() => {setIsOpen(false)}}\n                     isOpen={isOpen}\n                     openUp={openUp}\n                     openRight={openRight}\n                     clickPosition={clickPosition}>\n            {brushesLoaded ? brushlist : brushesLoading}\n        </ContextMenu>\n    )\n});\n\n","const addBrushName = (brush, patternString) => {\n    let searchIndex = 0;\n    const commentRegex = /#([CcNOPrR]).*/gm;\n    let comments = [];\n    let m;\n    let brushName;\n\n    while ((m = commentRegex.exec(patternString)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === commentRegex.lastIndex) {\n            commentRegex.lastIndex++;\n        }\n        comments.push(m[0]);\n        searchIndex = commentRegex.lastIndex\n    }\n    try {\n        brushName = comments[0].split(\"#N \")[1];\n        brush.name = brushName;\n        brush.displayName = brushName;\n\n        // skip the newline symbol\n        searchIndex++;\n        return searchIndex\n    } catch (e) {\n        console.log(e);\n        console.log(patternString)\n    }\n\n};\n\nconst addRowsAndCols = (brush, patternString, searchIndex) => {\n    let m;\n    const configRegex = /^x.+/gm;\n    configRegex.lastIndex = searchIndex;\n    let config = [];\n    while ((m = configRegex.exec(patternString)) !== null) {\n        if (m.index === configRegex.lastIndex) {\n            configRegex.lastIndex++;\n        }\n\n        config.push(m[0]);\n        searchIndex = configRegex.lastIndex\n    }\n\n    const [x, y] = config[0].split(\", \");\n    brush.cols = parseInt(x.split(\" = \")[1]);\n    brush.rows = parseInt(y.split(\" = \")[1]);\n\n    // skip the newline symbol\n    searchIndex++;\n    return searchIndex;\n};\n\nconst addTemplateToBrush = (brush, patternString, searchIndex) => {\n    const totalSize = brush.cols * brush.rows;\n    let template = new Uint8Array(totalSize);\n    let positionInTemplate = 0;\n\n    let count = 1,\n        in_number = false,\n        currentX = 0,\n        chr;\n\n    for (let len = patternString.length; searchIndex < len; searchIndex++) {\n        chr = patternString.charCodeAt(searchIndex);\n\n        if (chr >= 48 && chr <= 57) {\n            if (in_number) {\n                count *= 10;\n                count += chr ^ 48;\n            } else {\n                count = chr ^ 48;\n                in_number = true;\n            }\n        } else {\n            // b\n            if (chr === 98) {\n                // we can skip all these positions because we have 1D Uint8Array\n                // which is initialised to 0s\n                positionInTemplate += count;\n                currentX += count;\n                // A-Za-z\n            } else if ((chr >= 65 && chr <= 90) || (chr >= 97 && chr < 122)) {\n                currentX += count;\n                while (count--) {\n                    template[positionInTemplate] = 1;\n                    positionInTemplate++;\n                }\n            }\n            // $\n            else if (chr === 36) {\n                // we havent reached the end of cols, must skip ahead\n                if (currentX < brush.cols) {\n                    positionInTemplate += brush.cols - currentX;\n                }\n                // if we have a count at the end of line, we must skip\n                // couple of \"rows\"\n                if (count - 1) {\n                    positionInTemplate += (count - 1) * brush.cols\n                }\n                currentX = 0;\n            }\n            // !\n            else if (chr === 33) {\n                break;\n            }\n\n            // currentX = 0;\n            count = 1;\n            in_number = false;\n        }\n    }\n    brush.template = template;\n};\n\nexport async function parseRle(url) {\n    let response = await fetch(url);\n    const decoder = new TextDecoder(\"utf-8\");\n    const reader = response.body.getReader();\n    let rleFileString = '';\n    let brush = {};\n\n    while (true) {\n        const {done, value} = await reader.read();\n        if (done) {\n            break\n        }\n        rleFileString += decoder.decode(value);\n    }\n\n    let searchIndex = addBrushName(brush, rleFileString);\n    searchIndex = addRowsAndCols(brush, rleFileString, searchIndex);\n    addTemplateToBrush(brush, rleFileString, searchIndex);\n    return brush;\n}\n","import {useEffect, useState} from \"react\";\nimport {parseRle} from \"../parser/rle\";\n\nconst brushList = [\n    \"bigun.rle\",\n    \"crab.rle\",\n    \"glider.rle\",\n    \"glidertrain.rle\",\n    \"gosperglider.rle\",\n    \"hwss.rle\",\n    \"inlineinverter.rle\",\n    \"jaydot.rle\",\n    \"loafer.rle\",\n    \"lobster.rle\",\n    \"newgun2.rle\",\n    \"nms.rle\",\n    \"pixel.rle\",\n    \"rabbits.rle\",\n    \"simkinglider.rle\",\n    \"spacerake.rle\",\n    \"spider.rle\",\n    \"twogun.rle\",\n    \"wing.rle\",\n];\n\nexport function useBrushes(cols, rows) {\n    const [brushes, setBrushes] = useState([]);\n    const [loaded, setLoaded] = useState(false);\n    const [filteredBrushes, setFilteredBrushes] = useState([]);\n\n    useEffect(() => {\n        Promise.all(brushList.map(brush => parseRle(process.env.PUBLIC_URL + \"/patterns/\" + brush)))\n            .then(vals => {\n                setLoaded(true);\n                setBrushes(vals);\n            });\n    }, []);\n\n    useEffect(() => {\n        const smallerThanBoard = brushes.filter(brush => brush.cols <= cols && brush.rows <= rows)\n        setFilteredBrushes(smallerThanBoard);\n    }, [cols, rows, brushes]);\n\n    return [filteredBrushes, loaded];\n}\n","import React, {useRef, useEffect, useState, useCallback} from 'react';\nimport useInterval from \"./hooks/useInterval\";\nimport './App.scss';\nimport useWindowSize from \"./hooks/useWindowSize\";\nimport useBoard, {\n    getBoardWithAppliedBrushAndPaintedIndices,\n    handleBoardDimensionChange\n} from \"./hooks/useBoard\";\nimport {coordToIndex, indexToCoord} from \"./util\"\nimport {defaultBrush, rotateBrush90deg} from \"./components/Brushes\";\nimport Controls from \"./components/Controls\";\nimport {BrushHud} from \"./components/BrushHud\";\nimport {useBrushes} from \"./hooks/useBrushes\";\n\nconst INTERVAL = 50;\nconst CELLSIZE = 15;\nconst gridGap = 1;\nlet lastHoverCoord;\n\nconst mousePosToCoord = (eX, eY) => {\n    const x = Math.floor(eX / (CELLSIZE + gridGap));\n    const y = Math.floor(eY / (CELLSIZE + gridGap));\n    return {x, y};\n};\n\nconst intersection = (setA, setB) => {\n    let _intersection = new Set()\n    for (let elem of setB) {\n        if (setA.has(elem)) {\n            _intersection.add(elem)\n        }\n    }\n    return _intersection\n};\n\nlet touchMoved = false;\n\nfunction CanvasBoard({board, windowSize, cols, rows, setBoard, setCols, setRows, brush, setHoverBoard, hoverBoard, seed, lastPaintedHoverIndices, lastPaintedIndices, setLastPaintedHoverIndices, setLastPaintedIndices, isRunning}) {\n    const canvasRef = useRef(null);\n    const [lastMouseDownIndex, setLastMouseDownIndex] = useState(null);\n\n    const clearCanvas = (ctx) => {\n        ctx.clearRect(0, 0, windowSize.width, windowSize.height);\n    };\n\n    const drawCell = (ctx, cell, index, cols) => {\n        const {x, y} = indexToCoord(index, cols);\n        ctx.fillStyle = cell === 1 ? \"#00adb5\" : \"#393e46\";\n        ctx.fillRect(x * CELLSIZE + x, y * CELLSIZE + y, CELLSIZE, CELLSIZE)\n    };\n\n    const drawHoverCell = (ctx, cell, index, cols) => {\n        // draws only the alive cell in the template\n        // paints the cell only if it has been set to be hovered\n        if (cell === 1 && (isRunning || lastPaintedHoverIndices.has(index))) {\n            const {x, y} = indexToCoord(index, cols);\n            ctx.fillStyle = lastPaintedIndices.has(index) ? \"rgb(200,87,125)\" : \"rgba(238, 238, 238, 0.3)\";\n            ctx.fillRect(x * CELLSIZE + x, y * CELLSIZE + y, CELLSIZE, CELLSIZE)\n        }\n    };\n\n    useEffect(() => {\n        const newRows = Math.floor((windowSize.height + gridGap) / (CELLSIZE + gridGap));\n        const newCols = Math.floor((windowSize.width + gridGap) / (CELLSIZE + gridGap));\n        if (cols !== newCols || rows !== newRows) {\n            setBoard(handleBoardDimensionChange(board, cols, rows, newCols, newRows));\n            setRows(newRows);\n            setCols(newCols);\n        }\n    });\n\n    useEffect(() => {\n        const ctx = canvasRef.current.getContext(\"2d\");\n        clearCanvas(ctx);\n        for (let i = 0, boardLength = board.length; i < boardLength; i++) {\n            drawCell(ctx, board[i], i, cols);\n            drawHoverCell(ctx, hoverBoard[i], i, cols)\n        }\n    });\n\n    return (\n        <canvas\n            ref={canvasRef}\n            width={windowSize.width}\n            height={windowSize.height}\n            onClick={e => {\n                if (isRunning || intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0) {\n                    const cCoord = mousePosToCoord(e.pageX, e.pageY);\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(cCoord, board, cols, rows, brush)\n\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n            }}\n            onMouseLeave={() => setHoverBoard(seed)}\n            onTouchEnd={e => {\n                lastHoverCoord = mousePosToCoord(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n\n                if (isRunning ||\n                    intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0 ||\n                    !touchMoved) {\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush)\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n                touchMoved = false;\n                setHoverBoard(seed);\n                e.preventDefault()\n            }}\n            onTouchMove={(e) => {\n                touchMoved = true;\n                lastHoverCoord = mousePosToCoord(e.touches[0].clientX, e.touches[0].clientY);\n                const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, brush);\n                setLastPaintedHoverIndices(paintedIndices);\n                if (isRunning) {\n                    setLastPaintedHoverIndices(new Set());\n                } else {\n                    setLastPaintedHoverIndices(paintedIndices);\n                }\n                setHoverBoard(nBoard);\n                // allow dragging and placing smaller brushes like gliders and pixels\n                if ((brush.template.length < 17 &&\n                    (isRunning || intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0))) {\n                    const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush)\n                    if (isRunning) {\n                        setLastPaintedIndices(new Set());\n                    } else {\n                        setLastPaintedIndices(paintedIndices);\n                    }\n                    setBoard(nBoard)\n                }\n            }}\n            onMouseMove={(e) => {\n                lastHoverCoord = mousePosToCoord(e.pageX, e.pageY);\n\n                const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, brush);\n\n                if (isRunning) {\n                    setLastPaintedHoverIndices(new Set());\n                } else {\n                    setLastPaintedHoverIndices(paintedIndices);\n                }\n                setHoverBoard(nBoard);\n\n                if (e.buttons === 1 || e.buttons === 3) {\n                    const index = coordToIndex(lastHoverCoord, cols);\n                    if ((isRunning && index !== lastMouseDownIndex) ||\n                        (!isRunning && intersection(lastPaintedHoverIndices, lastPaintedIndices).size === 0)) {\n\n                        const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, board, cols, rows, brush);\n\n                        if (isRunning) {\n                            setLastPaintedIndices(new Set());\n                        } else {\n                            setLastPaintedIndices(paintedIndices);\n                        }\n                        setLastMouseDownIndex(index);\n                        setBoard(nBoard)\n                    }\n                }\n            }}\n        />\n    );\n}\n\nfunction BoardWrapper({cols, rows, seed, windowSize, setRows, setCols}) {\n    const [hoverBoard, setHoverBoard] = useBoard(rows, cols, seed);\n    const [board, setBoard, isRunning, setIsRunning, advanceBoard] = useBoard(rows, cols, seed);\n    const [selectedBrush, setSelectedBrush] = useState(defaultBrush);\n    const [lastPaintedIndices, setLastPaintedIndices] = useState(new Set());\n    const [lastPaintedHoverIndices, setLastPaintedHoverIndices] = useState(new Set());\n    const [brushes, brushesLoaded] = useBrushes(cols, rows);\n    const wrapperRef = useRef(null);\n\n    useInterval(advanceBoard, isRunning ? INTERVAL : null);\n\n    const setSelectedBrushCb = useCallback((newBrush) => {\n        setSelectedBrush(newBrush);\n    }, [setSelectedBrush]);\n\n    const toggleIsRunning = useCallback((event) => {\n        if (event.keyCode === 32 || event.type === \"click\") {\n            setLastPaintedIndices(new Set());\n            setIsRunning(!isRunning);\n        }\n    }, [isRunning, setIsRunning, setLastPaintedIndices]);\n\n    const touchHoverClear = useCallback(() => {\n        setHoverBoard(seed);\n    }, [setHoverBoard, seed]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", toggleIsRunning, false);\n        return () => {\n            document.removeEventListener(\"keydown\", toggleIsRunning, false)\n        };\n    }, [toggleIsRunning]);\n\n    const memoRotateBrush = useCallback((event) => {\n        if (event.code === \"KeyR\") {\n            setSelectedBrushCb(rotateBrush90deg(selectedBrush));\n            const {nBoard, paintedIndices} = getBoardWithAppliedBrushAndPaintedIndices(lastHoverCoord, seed, cols, rows, rotateBrush90deg(selectedBrush));\n            setLastPaintedHoverIndices(paintedIndices);\n            setHoverBoard(nBoard);\n        }\n    }, [setSelectedBrushCb, selectedBrush, seed, cols, rows, setHoverBoard]);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", memoRotateBrush, false);\n        return () => {\n            document.removeEventListener(\"keydown\", memoRotateBrush, false)\n        };\n    }, [memoRotateBrush]);\n\n    return (\n        <div className=\"App\" ref={wrapperRef}>\n            <BrushHud wrapperRef={wrapperRef}\n                      brushes={brushes}\n                      selectedBrush={selectedBrush}\n                      onBrushSelect={setSelectedBrushCb}\n                      brushesLoaded={brushesLoaded}/>\n            <CanvasBoard board={board}\n                         brush={selectedBrush}\n                         setBoard={setBoard}\n                         windowSize={windowSize}\n                         cols={cols}\n                         setCols={setCols}\n                         setRows={setRows}\n                         rows={rows}\n                         seed={seed}\n                         setHoverBoard={setHoverBoard}\n                         hoverBoard={hoverBoard}\n                         lastPaintedIndices={lastPaintedIndices}\n                         setLastPaintedIndices={setLastPaintedIndices}\n                         lastPaintedHoverIndices={lastPaintedHoverIndices}\n                         isRunning={isRunning}\n                         setLastPaintedHoverIndices={setLastPaintedHoverIndices}\n            />\n            <Controls advanceBoard={advanceBoard}\n                      toggleIsRunning={toggleIsRunning}\n                      isRunning={isRunning}\n                      setIsRunning={setIsRunning}\n                      setBoard={setBoard}\n                      board={board}\n                      touchHoverClear={touchHoverClear}\n                      setSelectedBrushWrapper={setSelectedBrushCb}\n                      selectedBrush={selectedBrush}\n                      setLastPaintedIndices={setLastPaintedIndices}\n                      brushes={brushes}\n                      brushesLoaded={brushesLoaded}/>\n        </div>\n    )\n}\n\nfunction App() {\n    const windowSize = useWindowSize();\n    // defaultBrush.distanceVec = brushDistanceVecFromCenter(defaultBrush);\n    const [rows, setRows] = useState(Math.floor((windowSize.height + gridGap) / (CELLSIZE + gridGap)));\n    const [cols, setCols] = useState(Math.floor((windowSize.width + gridGap) / (CELLSIZE + gridGap)));\n    const seed = Array(rows * cols).fill(0);\n\n    return (\n        <BoardWrapper rows={rows} cols={cols} seed={seed} windowSize={windowSize} setRows={setRows} setCols={setCols}/>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}